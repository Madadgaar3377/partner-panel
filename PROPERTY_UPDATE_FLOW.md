# Property Update Flow Documentation

## Backend API Configuration

### Route
```javascript
router.put("/updateProperty", verifyUser, updateProperty);
```

### Backend Logic (adminSide.js)
```javascript
exports.updateProperty = async (req, res) => {
    const {data} = req.body;
    const userId = req.user.userId;
    
    // Find property by propertyId (not MongoDB _id)
    const property = await Property.findOne({ propertyId: data.propertyId });
    
    if(!property){
        return res.status(404).json({
            success: false,
            message: "Property not found",
        });
    }
    
    // Update entire property with new data
    property.set(data);
    await property.save();
    
    return res.status(200).json({
        success: true,
        message: "Property updated successfully",
        property,
    });
};
```

## Frontend Implementation

### 1. Edit Route
- **URL Pattern:** `/property/edit/:id`
- **Component:** `EditProperty.jsx` → renders `CreateProperty.jsx`
- **Parameter:** `:id` is MongoDB `_id` (used to fetch property)

### 2. Loading Property for Editing

When user clicks "Edit" on a property:

```javascript
// PropertyList.jsx
navigate(`/property/edit/${property._id}`);
```

CreateProperty component detects `id` param and fetches property:

```javascript
useEffect(() => {
  if (id) {
    // Fetch property using MongoDB _id
    fetch(`${apiUrl}/getProperty/${id}`)
      .then(data => {
        const prop = data.property;
        
        // Extract propertyId from contact info
        const extractedPropertyId = 
          prop.project?.contact?.propertyId || 
          prop.individualProperty?.contact?.propertyId;
        
        setPropertyId(extractedPropertyId); // Store for updates
        setPropertyType(prop.type);
        
        // Load data into form
        if (prop.type === 'Project') {
          setProjectData(prop.project);
        } else {
          setIndividualData(prop.individualProperty);
        }
      });
  }
}, [id]);
```

### 3. Submitting Update

When user clicks "Update Property":

```javascript
const handleSubmit = async () => {
  // Validation
  if (id && !propertyId) {
    setError('Property ID is missing. Cannot update property.');
    return;
  }

  // Prepare payload
  const propertyData = {
    type: propertyType,
    project: propertyType === 'Project' ? projectData : undefined,
    individualProperty: propertyType === 'Individual' ? individualData : undefined,
  };

  // Add propertyId at root level for update
  if (id && propertyId) {
    propertyData.propertyId = propertyId; // Backend uses this to find property
  }

  const payload = { data: propertyData };

  // Send PUT request
  const response = await fetch(`${apiUrl}/updateProperty`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify(payload)
  });

  if (response.ok) {
    // Success - redirect to property list
    navigate('/property');
  }
};
```

## Data Flow Diagram

```
1. User clicks "Edit" button
   └─> Navigate to /property/edit/:mongoId

2. CreateProperty component loads
   └─> Fetch property using MongoDB _id
       └─> Extract propertyId from contact info
       └─> Load property data into form state

3. User edits property
   └─> State updates in real-time

4. User clicks "Update Property"
   └─> Construct payload with propertyId at root
       └─> Send PUT request to /updateProperty
           └─> Backend finds property by propertyId
           └─> Backend updates property
           └─> Return success response

5. Redirect to /property list
```

## Key Points

### propertyId vs MongoDB _id

1. **MongoDB _id**: 
   - Used for fetching property (GET requests)
   - URL parameter: `/property/edit/:id`
   - Route: `getProperty/:id`

2. **propertyId**:
   - Used for updating property (PUT requests)
   - Generated by backend on creation
   - Stored in `contact.propertyId` field
   - Must be included at root level in update payload

### Payload Structure

**Create Property:**
```json
{
  "data": {
    "type": "Project",
    "project": {
      "projectName": "...",
      "contact": {
        "name": "...",
        // propertyId will be generated by backend
      }
    }
  }
}
```

**Update Property:**
```json
{
  "data": {
    "propertyId": "PROP123456", // ← Required for update
    "type": "Project",
    "project": {
      "projectName": "...",
      "contact": {
        "propertyId": "PROP123456", // ← Also stored here
        "name": "..."
      }
    }
  }
}
```

## Testing Checklist

- [ ] Navigate to property list
- [ ] Click "Edit" on any property
- [ ] Verify property data loads correctly
- [ ] Check console for "Loaded property for editing" log
- [ ] Verify propertyId is extracted
- [ ] Modify property data
- [ ] Click "Update Property"
- [ ] Check console for "Updating property" log
- [ ] Verify PUT request to /updateProperty
- [ ] Verify payload includes propertyId
- [ ] Check for success message
- [ ] Verify redirect to property list
- [ ] Verify changes are saved

## Error Handling

1. **Missing propertyId**: Shows error "Property ID is missing. Cannot update property."
2. **Network Error**: Shows "Network error. Please try again."
3. **API Error**: Shows backend error message
4. **Property Not Found**: Backend returns 404 with message

## Debug Logs

The implementation includes console logs for debugging:

- **On Load:** "Loaded property for editing" with mongoId and propertyId
- **On Submit:** "Updating property" with mode, propertyId, method, and URL
- **On Error:** Full error details in console


